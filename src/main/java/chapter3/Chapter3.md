# Chapter 03. 코드에서 나는 악취

리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다. <br>

리팩터링의 종료에 대한 정확한 기준은 숙련된 사람의 직관만큼 정확한 기준은 없다. 
인스턴스 변수는 몇 개가 적당한지, 메서드가 몇 줄을 넘어가면 안 좋은지 등은 각자 경험을 통해 감을 키워야 한다. <br>

따라서 종료 기준보다는 **리팩터링하면 해결할 수 있는 문제의 징후**를 제시한다. <br>

## 기이한 이름(Mysterious Name)
- 코드를 명료하게 표현하는 데 가장 중요한 요소 중 하나는 '이름'이다. 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확하게 알 수 있도록 
신경써서 이름을 지어야 한다.
- 하지만 이름 짓기는 어렵다. 
  - 가장 많이 사용하는 리팩터링 기법: `함수 선언 바꾸기`, `변수 이름 바꾸기`, `필드 이름 바꾸기`
  - <b>마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 있을지도.</b>

## 중복 코드(Duplicated Code)
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용한다면? 
  - `함수 추출하기`를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾼다.
    ```java
    class Order {
      private double price;
      
      public Order(double price) {
          this.price = price;
      }
      
      public double getPriceWithTax() {
          return price + calculateTax();
      }
      
      public double getDiscountedPrice() {
          return price - getDiscount() + calculateTax();
      }
      
      private double calculateTax() { // 추출된 메서드
          return price * 0.1; // 세금 10%
      }
      
      private double getDiscount() {
          return price * 0.05; // 할인 5%
      }
    } 
    ```
 
  - 코드가 비슷하긴 한데 완전히 똑같지는 않다면?
    - `문장 슬라이드하기`로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.
    ```java
      class Invoice {
        private double amount;
        private double tax;
        private double discount;
    
        public Invoice(double amount) {
          this.amount = amount;
          slideStatements(); // 문장을 모아 가독성을 높임
        }
    
        private void slideStatements() {
          tax = amount * 0.1;
          discount = amount * 0.05;
        }
    
        public double getFinalAmount() {
          return amount + tax - discount;
        }
    }
    ```

- 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면?
  - `메서드 올리기`를 적용해 각자 따로 호출되지 않도록 부모로 옮긴다. 
  ```java
    class Employee {
        protected String name;
    
        public Employee(String name) {
            this.name = name;
        }
    
        public void printDetails() { // 부모 클래스로 올려 중복 제거
            System.out.println("Employee: " + name);
        }
    }

    class Manager extends Employee {
        public Manager(String name) {
            super(name);
        }
    }
    
    class Engineer extends Employee {
        public Engineer(String name) {
            super(name);
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            Order order = new Order(100);
            System.out.println("Price with Tax: " + order.getPriceWithTax());
            System.out.println("Discounted Price: " + order.getDiscountedPrice());
    
            Invoice invoice = new Invoice(200);
            System.out.println("Final Invoice Amount: " + invoice.getFinalAmount());
            
            Employee manager = new Manager("Alice");
            Employee engineer = new Engineer("Bob");
            manager.printDetails();
            engineer.printDetails();
        }
  }

  ```

## 긴 함수(Long Function)
오랜 기간 잘 활용되는 프로그램들은 하나같이 **짧은 함수**로 구성됐다. 예전 언어와 다르게, 요즘 언어는 프로세스 안에서 함수 호출 비용을 거의 없애버렸다.
<br>
코드를 읽는 사람이 함수가 하는 일을 파악하기 위해 왔다갔다하는 비용을 줄이고 싶다면, **좋은 이름을 지어서 본문 코드를 볼 이유가 사라지게 만들 수 있다.**

> 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
  - 함수 본문에는 주석으로 설명할 내용을 코드에 담는다.
  - 함수 이름은 동작 방식이 아닌 **코드의 목적(의도)**이 드러나게 짓는다.
    - ✔️ 핵심 : '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다. 함수의 길이가 길어지는 것은 문제가 되지 않음!


> 함수를 짧게 만드는 작업의 90%는 `함수 추출하기`이다.
  - 매개변수와 임시 변수를 많이 사용하면, 추출 작업에 방해가 된다.
  - `임시 변수를 질의 함수로 바꾸기`로 임시 변수의 수를, `매개변수 객체 만들기`와 `객체 통째로 넘기기`로는 매개변수의 수를 줄일 수 있다.
    - 그럼에도 여전히 임시 변수와 매개변수가 너무 많다면, 더 큰 수술이라 할 수 있는 `함수를 명령으로 바꾸기`를 고려해보자.

> 추출할 코드 덩어리는 어떻게 찾아낼까?
  1. 주석을 찾자. 
     - 주석이 설명하는 바를 코드로 추출하자.
  2. 조건문이나 반복문을 찾자.
     - `조건문 분해하기`
     - 거대한 switch 문을 구성하는 case 문마다 `함수 추출하기` 적용 ➡️ 각 case의 본문을 함수 호출문으로 대체
     - 같은 조건을 기준으로 나뉘는 case 문은 `조건부 로직을 다형성으로 바꾸기` 적용

## 긴 매개변수 목록(Long Parameter List)
매개변수 목록이 길어지면 그 자체로 이해가 어려울 때가 많다.
 
- `매개변수를 질의 함수로 바꾸기`
  - 다른 매개변수에서 값을 얻어올 수 있는 매개변수를 질의 함수로 바꿈으로써 제거할 수 있다.


- `객체 통째로 넘기기`
  - 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면, **원본 데이터 구조를 그대로 넘기자**.
  - 항상 함께 전달되는 매개변수들은 `매개변수 객체 만들기`로 하나로 묶어버린다.
  - 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 `플래그 인수 제거하기`로 없애준다.

- `여러 함수를 클래스로 묶기`
  - 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이다. 특히, 여러 개의 함수가 **특정 매개변수들의 값을 공통으로 사용할 때** 유용하다.
  - 여러 함수를 클래스로 묶어서, 공통 값들을 클래스의 필드로 정의한다.

## 전역 데이터(Global Data)
전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없기 때문에 주의해야 한다.
대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

- `변수 캡슐화하기`
  - 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다. 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 
  쉽게 찾을 수 있고 접근을 통제할 수 있다.
  - 접근자 함수를 활용해서 접근 범위를 최소로 줄이는 것도 고려하자.

**전역 데이터는 아주 조금만 있더라도 캡슐화를 권장**한다. 그래야 소프트웨어가 진화하는 데 따른 변화에 대처할 수 있다.

## 가변 데이터(Mutuable Data)
데이터 변경을 코드의 다른 곳에서 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다. 

따라서 함수형 프로그래밍에서는 데이터는 불변을 기본으로 삼는다. 데이터를 변경하려면 반드시 변경하려는 값에 해당되는 복사본을 만들어서 반환한다.
하지만 함수형 언어가 프로그래밍에서 차지하는 비중은 여전히 적다. 

그렇다면 이러한 프로그래밍에서 **무분별한 데이터 수정에 따른 위험을 어떻게 줄일 수 있을까?**

- `변수 캡슐화하기`
  - 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하여, 값이 어떻게 수정되는지 감시하거나 코드 개선을 쉽게 만들 수 있다.


- `변수 쪼개기`
  - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면, 변수를 쪼개서 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.


- `문장 슬라이드하기`, `함수 추출하기`
  - 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리하자.


- `질의 함수와 변경 함수 분리하기`
  - API를 만들 때는 질의 함수와 변경 함수를 분리해서, 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.
  - 가능한 한 `세터 제거하기`도 적용한다. 간혹 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움이 될 때가 있다.


- `파생 변수를 질의 함수로 바꾸기`
  - 값을 다른 곳에서 설정할 수 있는 가변 데이터는 혼동과 버그와 야근을 부를 뿐만 아니라, 쓸데없는 코드이기도 하다.
  - 파생 변수를 질의 함수를 바꿔서 코드 전체에 뿌려주자.


- `여러 함수를 클래스로 묶기`, `여러 함수를 변환 함수로 묶기`
  - 변수의 유효범위가 단 몇 줄이라면 가변 데이터일지라도 문제 여지가 거의 없지만, 나중에 유효범위가 넓어질 수 있고 위험이 커질 수 있다.
  - 여러 함수를 클래스로 묶거나, 변환 함수로 묶어서 변수를 갱신하는 코드들의 유효 범위를 클래스나 변환으로 제한하자. 
  - 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, `참조를 값으로 바꾸기`를 적용해서 내부 필드를 직접 수정하지 않고 구조체를 통째로 교체하는 편이 낫다.
    (공유 참조 문제를 일으킬 수 있기 때문)
    ```java
        class Address {
            String city;
        
            public Address(String city) {
                this.city = city;
            }
        
            public void setCity(String city) { // 필드 직접 변경
                this.city = city;
            }
        
            public String getCity() {
                return city;
            }
        }
        
        class Customer {
            private Address address;
        
            public Customer(Address address) {
                this.address = address;
            }
        
            public void updateCity(String newCity) { // 내부 값 수정
                address.setCity(newCity);
            }
        
            public Address getAddress() {
                return address;
            }
        }
    ```

## 뒤엉킨 변경(Divergent Change)
코드를 수정할 때는 시스템에서 **고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다**. 이렇게 할 수 없다면 `뒤엉킨 변경`과 `산탄총 수술` 중 
하나가 풍긴다.

- `뒤엉킨 변경`
  - 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 발생
  - 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생

Ex.<br> 
지원해야할 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 하고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이 발생했다는 뜻이다.

로직:<br>
데이터베이스에서 데이터를 가져온다. ➡️ 금융 상품 로직을 순차적으로 실행한다.

리팩터링:<br>
1. `단계 쪼개개`: 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다.
2. `함수 옮기기`: 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다.
그러면 처리 과정이 맥락별로 구분된다.
3. `함수 추출하기`: 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 함수 추출하기부터 수행한다.
4. `클래스 추출하기`: 모듈이 클래스라면 클래스 추출하기가 맥락별 분리 방법을 알려줄 것.

⭐️ 핵심 해법은 `맥락별로 분리`

## 산탄총 수술(Shotgun Surgery)
코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

리팩터링:
- 함께 변경되는 대상들을 `함수 옮기기`와 `필드 옮기기`로 모두 한 모듈에 묶어주면 좋다.
- 비슷한 데이터를 다루는 함수가 많다면 `여러 함수를 클래스로 묶기`를 적용
- 데이터 구조를 변환하거나 보강하는 함수들에는 `여러 함수를 변환 함수로 묶기`를 적용
- 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 `단계 쪼개기`를 적용
- 어설프게 분리된 로직을 `함수 인라인화하기` 또는 `클래스 인라인하기`로 하나로 합치는 것도 좋은 방법

⭐️ 핵심 해법은 `맥락별로 모음`. 이때 코드를 재구성하는 중간 과정에는 큰 덩어리로 뭉쳐지는데 개의치 않는다.

## 기능 편애(Feature Envy)
- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새


- Ex. 외부 객체의 게터 메서드 대여섯 개를 호출하도록 작성된 함수 
  - `함수 옮기기`: 해당 함수는 데이터와 가까이 있고 싶어하니 데이터 근처로 옮겨주자.
  - 함수의 일부에서만 기능을 편애하고 싶다면, 그 부분만 독립 함수로 빼낸 다음(`함수 추출하기`) 원하는 모듈로 보내주자.(`함수 옮기기`)


- Ex2. 함수가 사용하는 모듈이 다양하다면 어느 모듈로 옮길까?
  - 가장 많은 데이터를 포함한 모듈로 옮긴다.
  - `함수 추출하기`로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결할 수 있다.

## 데이터 뭉치(Data Clumps)
데이터 항목 여러 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 볼 수 있다. <br>
Ex. 클래스 두 어개의 필드, 여러 메서드의 시그니처 <br>

이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 만들어주자.

1. 필드 형태의 데이터 뭉치를 찾아서 `클래스 추출하기`로 하나의 객체로 묶는다.
2. 메서드 시그니처에 있는 데이터 뭉치를 처리해보자.
   -  `매개변수 객체 만들기`나 `객체 통째로 넘기기`를 적용해서 매개변수 수를 줄여본다.
   - 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 예전보다 나아진다.
   - 데이터 뭉치인지 판별 기준 : 값 하나를 삭제했을 때 나머지 데이터만으로 의미가 없다면 객체로 만드는 것을 고려해보자.
3. 새로운 클래스를 만들었다면, 그 클래스로 옮기면 좋은 동작을 고민해본다.
   - 이러한 과정은 종종 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시킬 수 있다.

## 기본형 집착(Primitive Obsession)
- `기본형을 객체로 바꾸기`를 적용하여 의미있는 자료형으로 만드는 것을 고려하자.
- 기본형으로 표현된 코드를 조건부 동작을 제어하는 타입 코드로 쓰였다면 `타입 코드를 서브클래스로 바꾸기`와 `조건부 로직을 다형성으로 바꾸기`를 차례로 적용한다.
- 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치로, `클래스 추출하기`와 `매개변수 객체 만들기`를 이용해서 개선하자.

## 반복되는 switch문(Repeated Switches)
- 단순히 if문이나 switch문과 같은 모든 `조건부 로직을 다형성으로 바꾸기`를 적용할 필요는 없다.
- 똑같은 조건부 로직(switch/case문 또는 길게 나열된 if/else문)이 여러 곳에서 반복해 등장하는 코드를 개선해보자.
  - 중복된 switch문은 조건절을 하나 추가할 때마다 다른 switch문들도 함께 수정해야하기 때문으로, 다형성을 이용해 반복된 switch문을 개선하자.

## 반복문(Loops)
- 일급 함수를 지원하는 언어가 많아졌기 때문에 `반복문을 파이프라인으로 바꾸기`를 적용해서 반복문을 개선해보자.
- 필터나 맵 같은 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 성의 없는 요소(Lazy Element)
원래 풍성했던 클래스가 리팩터링과 같은 이유로 역할이 줄어들었다면, 제거하는 것이 좋다.

- 제거 작업은 `함수 인라인하기`나 `클래스 인라인하기`로 처리한다. 
- 상속을 사용했다면 `계층 합치기`를 적용하자.

## 추측성 일반화(Speculative Generality)
나중에 필요할 거란 생각으로 당장 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다. <br>
미래에 실제로 사용하면 다행이지만, 그렇지 않다면 쓸데없는 낭비임! 걸리적거리는 코드는 지우자.


- 하는 일이 거의 없는 추상 클래스는 `계층 합치기`로 제거한다.
- 쓸데없이 위임하는 코드는 `함수 인라인하기`나 `클래스 인라인하기`로 삭제한다.
- 본문에서 사용되지 않는 매개변수는 `함수선언 바꾸기`로 없앤다. 


추측성 일반화는 테스트 코드말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다.
이런 코드를 발견하면 테스트 케이스부터 삭제한 후, `죽은 코드 제거하기`로 날려버리자.

## 임시 필드(Temporary Field)
특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있다. <br>
하지만 객체는 당연히 모든 필드가 채워져 있을 거라 생각하는 게 보통이다. 

- 임시 필드를 발견하면, `클래스 추출하기`로 위치를 찾아준다.
- 이후 `함수 옮기기`로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣는다.
- 임시 필드가 유효한지 확인한 후 동작하는 조건부 로직을 `특이 케이스 추가하기`로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할 수 있다.

## 메시지 체인(Message Chains)
다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.<br>
내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.

- `위임 숨기기`로 해결하자. 
  - 메서드 체인의 다양한 연결점에 적용할 수 있다.
  - 그러다보면 중간 객체가 모두 중개자가 돼버리기 쉽다.
  - 그러니 **최종 결과 객체가 어떻게 쓰이는지부터 살펴보는게 좋다**.
  ```java
    // 부서장 이름을 바로 반환하는 메서드를 사람 클래스 또는 부서 클래스에 추가할 수 있다.
    managerName = aPerson.department.manager.name;
    managerName = aPerson.department.managerName; // 관리자 객체(manager)의 존재를 숨김
    managerName = aPerson.manager.name; // 부서 객체(department)의 존재를 숨김
    managerName = aPerson.managerName; // 부서 객체와 관리자 객체 모두의 존재를 숨김
  ```
- `함수 추출하기`로 결과 객체를 사용하는 코드 일부를 따로 빼낸다.
- `함수 옮기기`로 체인을 숨길 수 있는지 살펴본다.
  ```java
    // 보고서 생성 로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감춰진다.
    console.log(reportAutoGenerator.report(aPerson));
  ```
- 체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중 그 이후의 객체들도 사용하길 원하는 클라이언트도 제법 된다면, 이 요구를 처리해줄 메서드를 추가한다.
  ```
    체인의 중간인 부서 정보를 얻어 사용하는 다수 클라이언트가 부서장 이름도 함께 사용한다면,
    부서 클래스에 managerName() 메서드를 추가하여 체인을 단축할 수 있다.
  ```

## 중재자(Middle Man)
외부로부터 세부사항을 숨겨주는 **캡슐화(encapsulation)** 가 있다. 캡슐화 과정에서 **위임(delegation)** 이 자주 활용된다. <br>
Ex. 팀장에게 미팅을 요청했을 때, 팀장은 자신의 일정을 확인한 후 답을 준다. 그 과정에서 우리는 팀장의 일정 체크방식을 알지 않아도 된다.
<br><br>
하지만 클래스의 메서드 중 절반이 다른 클래스에 구현을 위임하는 것은 문제가 된다.
- `중개자 제거하기`를 활용해서 실제로 일을 하는 객체와 직접 소통하게 한다.
- 위임 메서드를 제거한 후 남은 일이 거의 없다면, `함수 인라인화하기`를 통해 호출하는 쪽으로 인라인하자.

## 내부자 거래(Insider Trading)
모듈 사이의 데이터 거래가 많으면 결합도(coupling)이 높아지고, 이는 좋지 않다. 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

- 은밀히 데이터를 주고받는 모듈들이 있다면 `함수 옮기기`와 `필드 옮기기` 기법으로 떼어놓아서 사적으로 처리하는 부분을 줄이자.
- 여러 모듈이 같은 관심사를 공유한다면, 
  - 공통 부분을 정식으로 처리하는 제 3의 모듈을 새로 만들거나,
  - `위임 숨기기`를 이용해 다른 모듈이 중간자 역할을 하게 한다.
- 상속 구조에서 부모 자식 사이에 결탁이 생길 수 있다.
  - 자식 클래스는 항상 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 한다.
  - 그러다가 부모 품을 떠나야할 때가 온다면 `서브클래스를 위임으로 바꾸기`나 `슈퍼클래스를 위임으로 바꾸기`를 활용하자.

## 거대한 클래스(Large Class)
한 클래스가 너무 많은 일을 하려다 보면 필드 수가 늘어나고, 필드가 많으면 중복 코드가 생기기 쉽다.

- `클래스 추출하기`로 필드들 일부로 따로 묶는다.  
  - Ex. depositAmount, depositCurrency 필드
  - 한 클래스 안에서 접두어나 접미어가 같은 필드들
- 분리할 컴포넌트가 원래 클래스와 상속관계가 더 적합하다면, `슈퍼클래스 추출하기`나 `타입 코드를 서브클래스로 바꾸기`를 적용하자. 

## 서로 다른 인터페이스의 대안 클래스들(Alternative Classes with Different Interfaces)
클래스의 장점 중 하나는 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것. 단, 교체하려면 인타페이스가 동일해야 한다.

- `함수 선언 바꾸기`로 메서드 시그니처를 일치시킨다.
- 부족하다면, `함수 옮기기`를 이용해서 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
- 그러다 대안 클래스들 사이에 중복 코드가 생기면 `슈퍼클래스 추출하기`를 고려하자.

## 데이터 클래스(Data Class)
데이터 클래스는 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 데이터 저장용도로만 쓰이다 보니 다른 클래스가 함부로 다룰 때가 많다.

- 데이터 클래스에 public 필드가 있다면 얼른 `레코드 캡슐화하기`로 숨기자.
- 변경하면 안되는 필드는 `세터 제거하기` 적용
- 다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아서 `함수 옮기기`를 적용해서 그 메서드를 데이터 클래스로 옮길 수 있는지 살펴보자.
  - 메서서드를 통째로 옮기기 어렵다면, `함수 추출하기`를 이용해서 옮길 수 있는 부분만 별도 메서드를 뽑아낸다.
- 단, 데이터 구조가 불변 필드로 구성된다면, 굳이 캡슐화할 필요가 없으며 게터 없이 바로 필드 자체를 공개해도 무방하다. 

## 상속 포기(Refused Bequest)
서브 클래스는 부모로부터 메서드와 데이터를 물려받지만, 부모의 유산 중 일부는 물려받고싶지 않다면?<br>
이는 **계층구조를 잘못 설계했기 때문**으로 본다.

- 같은 계층에 서브 클래스를 하나 새로 만든다. 
- `메서드 내리기`와 `필드 내리기`를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다. 
  그러면 부모에는 공통된 부분만 남게된다.

상속 포기 냄새는 **서브클래스가 부모의 동작은 필요로하지만, 인터페이스는 따르고 싶지 않을 때** 특히 심하게 난다.<br>
구현을 따르지 않는 것은 이해할 수 있지만, **인터페이스를 따르지 않는 것은 상당히 무례한 태도**다.

- `서브클래스를 위임으로 바꾸기`나 `슈퍼클래스를 위임으로 바꾸기`를 활용해서 아예 상속 메커니즘에서 벗어나보자.

## 주석(Comments)
주석은 악취가 아닌 향기. 다만 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.

- **가장 첫 레이어의 진입점과 인터페이스는 주석을 디테일하게 다는 것**을 권장한다. 
  - Ex. 파라미터마다 어떤 식으로 사용되는지, 어떤 식으로 사용되는지, null 값은 허용하는지, 한국에서는 어려운 영어 이름, 어떤 예외들을 반환하는 지 
  - 전반적인 기능 목록이나 모듈 구조, 빌드 과정은 코드를 보고 직접 이해하는 것보다 상위 수준에서 정리한 문서를 참조하는 것이 소프트웨어 전반을 빠르게 이해하는 데 
  도움이 된다. 
  
- 하지만 계속 업데이트되는 코드에 따라 **주석 역시 최신화**하는 것을 명심할 것.
- 남들은 내 머릿 속 생각을 한눈에 이해하기 힘들다. 내가 **미래에 어떤 작업들을 더 해야하는 지** 등 구체적으로 잘 작성하자. 
- 커밋 메시지를 주석 대신 상세하게 적는 것도 좋지만, 기본은 주석을 잘 작성하는 것.