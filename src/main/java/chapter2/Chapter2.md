# Chapter 02. 리팩터링 원칙

## 리팩터링 정의
[명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다. <br>
    Ex. 
        리팩터링 : 코드가 이해하기 쉽고 수정하기 좋아졌지만, 똑같이 동작한다.    
        성능최적화 : 속도 개선되었지만, 똑같이 동작한다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.


## 두 개의 모자
두 개의 모자인 '기능 추가' OR '리팩터링'을 명확히 구분해서 작업한다.
- 기능 추가 : 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 진척도는 테스트를 추가해서 통과여부로 측정한다.
- 리팩터링 : 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성만 전념한다. 앞 과정에서 놓친 tc를 발견하지 않는 한, 테스트도 추가하지 않는다.

## 리팩터링하는 이유
- 소프트웨어 설계가 좋아진다. 같은 일을 하더라도 설계가 나빠지면 중복 코드가 많아져서 코드가 길어지기 쉽다.
- 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다.
- 내 기억 용량을 믿지말고, 기억할 필요가 있는 것들은 최대한 코드에 담는다.
- 코드가 하는 일을 깊이 파악할 수 있으며, 프로그램의 구조를 명확히 다듬으로써 버그를 쉽게 찾을 수 있다.
- 프로그래밍 속도가 높아진다. 리팩터링을 하지 않으면, 새로운 기능을 추가할수록 기존의 코드베이스에 잘 녹여낼 방법을 찾는데 시간이 늘어나며 버그 발생 확률이 높아진다.

> 난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요. -켄트백

## 언제 리팩터링해야 할까?

**3의 법칙(삼진 리팩터링) - 돈 로버츠**
1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실이 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

**준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
- 가장 좋은 시점은 **코드베이스에 기능을 새로 추가하기 직전**이다.
- 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.
  
> 비유하면 지금 위치에서 동쪽으로 100km를 이동하려는데 그 사이를 숲이 가로막고 있다면, 좀 둘러가더라도 20km 북쪽에 있는 고속도를 타는 편이 세 배나 빠를 수 있다.
> 다들 "직진!"을 외치더라도, 때로는 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다.

**이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
- 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아보자.
- Ex. 조건부 로직의 구조가 이상하지는 않은가, 함수 이름을 잘못 정해서 역할 파악이 오래걸린다거나
- 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

**쓰레기 줍기 리팩터링**
- 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모를 남긴 다음, 하던 일을 끝내고 처리한다.
- 수정하려면 오래걸리거나 당장 더 급한 일이 있을 수 있지만, 캠핑 규칙처럼 조금이나마 개선해두는 것이 좋다. 코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이다.
- 리팩터링의 장점은 작업을 잘게 나누어 몇 달에 걸쳐 진행하더라도 그 한순간도 코드가 깨지지 않는다는 것.

**계획된 리팩터링과 수시로 하는 리팩터링** <br>
위의 세 가지 리팩터링 방식은 모두 기회가 될 때만 한다. 따로 리팩터링 일정을 잡지 않는다.

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

> 무언가 수정하려 들 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자. _켄트백

소프트웨어 개발을 끝이 있는 작업으로 보지 않는다. 새 기능이 필요하 때마다 소프트웨어는 이를 반영하기 위해 수정된다. 이때 새로 작성해 넣는 코드보다 기존 코드의 
수정량이 큰 경우가 대체로 많다.

리팩터링에 소홀했다면 계획된 리팩터링을 할 필요가 있다. **한편, 정기적으로 리팩터링하더라도 어떤 문제는 팀원 여럿이 달려들어야 할 정도로 곪아갈 수 있기에 계획된 
리팩터링은 최소한으로 줄여야 한다. 대부분은 드러나지 않게, 기회가 될 때마다 하자.** 팀에 적합한 방식은 실험을 통해 찾아낸다.

**오래 걸리는 리팩터링** <br>
팀 전체가 리팩터링에 매달리는 데는 회의적이다.  <br>
그보다 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다. 누구든지 관련된 작업을 할 때 원하는 방향으로 조금씩 개선해 나가는 식이다.
일부를 변경해도 코드가 올바르게 동작한다는 점을 활용하자.

**관리자에게는 뭐라고 말해야 할까?** <br>
기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이런 경우에는 **"리팩터링한다고 말하지 말라"**.
프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것, 일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 그리고 구체적인 
방법은 개발자가 판단해야 한다. 가장 빠른 방법은 리팩터링이니, 리팩터링부터 한다.

**리팩터링하지 말아야할 때** <br>
- 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다. 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.
- **내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.**
- `리팩터링` < `새로 작성하는 게 쉬울 때`도 리팩터링하지 않는다. 어떤 경우가 쉬운지 판단하는 것은 어렵고, 뛰어난 판단력과 경험이 뒷받침돼야 한다.

## 리팩터링 시 고려할 문제

**새 기능 개발 속도 저하** <br>

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

- 개발팀을 이끌고 있다면 코드베이스가 더 건강해지는 것을 추구한다는 사실을 팀원들에게 명확히 밝혀야 한다. 
- 리팩터링 할지 말지 판단 능력은 수년에 걸친 경험을 통해 서서히 형성된다. 
- 리더는 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 한다.


- 리팩터링의 본질은 **코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로, 개발 기간을 단축하고자 하는 것**. 
- 스스로 인식하는 것을 넘어 팀원과 대화할 때도 이를 명심하자.

**코드 소유권**
- 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다.
- 여전히 훌륭하게 개선할 순 있지만 제약이 따를 뿐이다. 코드베이스에서 곧바로 수정하면 훨씬 간단할 일을 계속해서 인터페이스를 관리하는 결과를 초래.
- 선호하는 방식은 코드의 소유권을 팀에 두는 것, 팀원이라면 누구나 수정할 수 있다.

**레거시 코드**
- **레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다. 하지만 대규모 레거시 시스템의 정답은 테스트 보강이다.**
- 테스트를 염두하고 설계한 시스템은 쉽게 테스트할 수 있지만, 그 외의 경우엔 훨씬 까다롭다. 
  - 책 추천 : 레거시 코드 활용 전략 (에이콘, 2018)
- 테스트를 갖추고 있더라도 복잡하기 얽힌 레거시 코드를 단번에 리팩터링하는 것은 쉽지 않기에, **서로 관련된 부분끼리 나눠서 하나씩 공략하라.**

## 리팩터링, 아키텍처, 애그니(YAGNI)

리팩터링은 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꿔놓았다. 코딩 시작하기 전에 소프트웨어 설계와 아키텍처는 거의 완료해야 한다고 배웠다. 
하지만 리팩터링으로 기존 코드의 설계를 개선할 수 있다.

## 리팩터링과 소프트웨어 개발 프로세스

테스트 주도 개발(TDD) : 자가 테스트 코드 + 리팩터링

- 리팩터링의 첫 번째 토대는 **자가 테스트 코드**다. 
- **지속적 통합**을 권장한다. 
  - 팀으로 개발하면서 리팩터링을 하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 하기 때문이다.
  - 팀원 각자가 수행한 리팩터링 결과를 빠르게 공유할 수 있고, 조만간 삭제될 인터페이스 참조 작업을 방지할 수 있으며, 리팩터링 결과가 다른 팀원의 작업에 문제를 일으키면 즉시 알아낼 수 있다.

✔️ `자가 테스트 코드, 지속적 통합, 리팩터링` 세 기법을 적용한다면 YAGNI(You aren't going to need it) 설계 방식을 실현할 수 있다.

- 실무에 바로 적용하긴 만만치 않으니, 충분한 연습과 실력이 뒷받침돼야 한다.

## 리팩터링과 성능

`직관적인 설계 vs. 성능`
- 리팩터링하면 소프트웨어가 느려질 수 있는 것은 사실이나, 성능 튜닝하기는 더 쉬워진다.
- 대부분의 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비하기에, 전체 코드를 최적화하면 90%는 시간낭비이다.
- 따라서, 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다. 그 후 성능에 큰 영향을 주는 부분을 집중해서 최적화하자.
