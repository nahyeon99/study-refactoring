# Chapter 01. 리팩터링: 첫 번째 예시

> 구현한 예시들은 대규모 시스템에서 발췌한 코드라고 상상하며 진행할 것

## 기능 요구사항 정리 및 코드 작성
- 주제 : 공연료 계산 프로그램
- 공연 요청이 들어오면 연극의 장르(비극, 희극)와 관객 규모를 기초로 비용을 책정한다.
- 공연료와 별개로 포인트(volume credit)을 지급해서 다음 번 의뢰 시 공연료를 할인받을 수 있다.
- plays.json(연극 정보), invoices.json(공연료 청구서 데이터)를 제공한다.
- 실행한 결과는 다음과 같다.
```
청구 내역 (고객명 : BigCo)
  Hamlet: $650.00 (55석)
  As You Like It: $580.00 (35석)
  Othello: $500.00 (40석)
총액: $1,730.00
적립 포인트: 47점
```

> 설계가 나쁜 시스템은 수정하기 어렵다. 리팩터링이 필요한 이유는 이후 코드 수정 과정에서 실수할 가능성을 줄이고 효율을 높이기 위함이다. 
> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.

## 1단계 : 테스트 코드 작성

> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

## 2단계 : 함수 쪼개기
### amountFor(aPerformance) 함수 추출하기 
> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
1. 별도 함수를 빼냈을 때 유효범위를 벗어나는 변수로 새 함수에서도 필요하지만 값을 변경하지 않는 경우 매개변수로 전달한다.
2. 함수 안에서 값이 바뀌는 변수를 반환한다. 이때 해당 변수는 조심히 다뤄야 한다.  
3. 함수 코드를 더 명확하게 표현하도록 검토한다.
   - 함수의 반환 값인 변수명은 result로 통일한다.
   - 동적 타입 언어를 사용할 때 타입을 명확하게 작성한다. 
   - 매개변수 이름에 접두어로 타입 이름을 적는데, 매개변수의 역할이 뚜렷하지 않을 때는 부정관사(a/an)를 붙인다.
> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.

### play 변수 제거하기
- 임시 변수를 질의 함수로 바꾸기
- 변수 인라인하기
- 함수 선언 바꾸기
  1. 매개변수 play를 질의 함수 playFor() 호출로 변경 
  2. 필요 없어진 매개변수 제거
- 변수 인라인하기

> 로컬 유효범위의 변수가 줄어서 함수 추출하기가 쉬워졌다.

### 적립 포인트 계산 코드 추출하기
- 값 누적 함수 추출하기
- 변수명 네이밍 변경

### format 변수 제거하기
- 함수 변수를 함수 호출로 대체
- 함수 선언 바꾸기
- 단위 변환 로직을 함수 안으로 이동

### volumeCredits 변수 제거하기
- 반복문 쪼개기로 변수 값 누적 로직 분리
- 문장 슬라이드하기로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮기기
- 함수 추출하기로 적립 포인트 계산 부분을 별도 함수로 추출
- 변수 인라인하기로 volumeCredits 변수 제거

> 소프트웨어 성능은 대체로 코드의 몇몇 작은 부분에 의해 결정되므로 그 외의 부분은 수정한다고 성능 차이를 체감할 수 없다.
때로는 영향을 줄지라도, 잘 다듬어진 코드가 성능 개선 작업도 훨씬 수월하다. 따라서 **특별한 경우가 아니라면 리팩터링을 마무리하고 나서 성능을 개선하자.**

### totalAmount 제거하기
- 반복문 쪼개기
- 문장 슬라이드
- 함수 추출
- 변수 인라인하기

## 3단계 : 단계 쪼개기
- renderPlainText 함수 추출하기
- StatementData 중간 데이터 구조 생성
- StatementData 중간 데이터 구조를 renderPlainText 함수의 인수로 전달
- 기존 renderPlainText 함수의 인수를 중간 데이터 구조로 이동
  - 고객 정보 이동, 고객 정보를 중간 데이터로부터 얻음
  - 공연 정보 이동, 공연 정보를 중간 데이터로부터 얻음
- 기존 인수 제거
- 얕은 복사를 위한 EnrichPerformance 클래스 추가
- 함수 옮기기
- 함수 호출을 중간 데이터를 사용하도록 변경
- 반복문을 파이프라인으로 변경

### 계산 단계와 포맷팅 단계 분리하기
- 계산 로직 : StatementData, EnrichPerformance 클래스 담당
- 포맷팅 로직 : Statement 클래스 담당

 각 부분과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워진다. 모듈화 덕분에 계산 코드의 중복을 제거할 수 있다.

> 캠핑자들에게는 "도착했을 때보다 깔끔하게 정돈하고 떠난다"는 규칙이 있다. 프로그래밍도 마찬가지다. 항시 코드베이스를 작업 시간 전보다 건강하게(healthy)
> 만들어놓고 떠나야 한다.

## 4단계 : 다형성을 활용해 계산 코드 재구성하기
여러 리팩터링 기법 중 **조건부 로직을 다형성**으로 바꾸기로 진행한다. 
이 리팩터링은 조건부 코드 한 덩어리를 다형성을 활용하는 방식으로 바꿔준다. 먼저 상속 계층부터 정의한다.
- 공연료 계산기 클래스(PerformanceCalculator) 만들기
  - 공연 관련 데이터를 다루는 공연료 계산기 클래스 생성
  - 생성자에 함수 선언 바꾸기를 적용하여 공연정보를 계산기로 전달
- 함수들을 계산기로 옮기기
  - 공연료 계산 코드를 계산기 클래스 안으로 복사
  - 원본 함수가 새로운 함수로 작업을 위임하도록 변경
  - 원래 함수를 인라인하기
- 공연료 계산기를 다형성 버전으로 만들기
  - 생성자를 팩터리 함수로 바꾸기
  - 타입 코드를 서브클래스로 바꾸기
  - 조건부 로직을 다형성으로 바꾸기
  - 슈퍼 클래스의 기존 메서드는 삭제 혹은 대체 작업(추상클래스, 예외처리 등)

> 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다. 리팩터링의 핵심은 단계를 잘게 나눠야 더 빠르게 처리할 수 있고(컴파일-테스트-커밋), 코드는 
> 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.
